# SPARC Agentic Development Rules
# from https://gist.github.com/ruvnet/7d4e1d5c9233ab0a1d2a66bf5ec3e58f

Core Philosophy

1. Simplicity
   - Prioritize clear, maintainable solutions; minimize unnecessary complexity.

2. Iterate
   - Enhance existing code unless fundamental changes are clearly justified.

3. Focus
   - Stick strictly to defined tasks; avoid unrelated scope changes.

4. Quality
   - Deliver clean, well-tested, documented, and secure outcomes through structured workflows.

5. Collaboration
   - Foster effective teamwork between human developers and autonomous agents.

Methodology & Workflow

- Structured Workflow
  - Follow clear phases from specification through deployment.
- Flexibility
  - Adapt processes to diverse project sizes and complexity levels.
- Intelligent Evolution
  - Continuously improve codebase using advanced symbolic reasoning and adaptive complexity management.
- Conscious Integration
  - Incorporate reflective awareness at each development stage.

Agentic Integration with Cline and Cursor

- Cline Configuration (.clinerules)
  - Embed concise, project-specific rules to guide autonomous behaviors, prompt designs, and contextual decisions.

- Cursor Configuration (.cursorrules)
  - Clearly define repository-specific standards for code style, consistency, testing practices, and symbolic reasoning integration points.

Memory Bank Integration

- Persistent Context
  - Continuously retain relevant context across development stages to ensure coherent long-term planning and decision-making.
- Reference Prior Decisions
  - Regularly review past decisions stored in memory to maintain consistency and reduce redundancy.
- Adaptive Learning
  - Utilize historical data and previous solutions to adaptively refine new implementations.

General Guidelines for Programming Languages

1. Clarity and Readability
   - Favor straightforward, self-explanatory code structures across all languages.
   - Include descriptive comments to clarify complex logic.

2. Language-Specific Best Practices
   - Adhere to established community and project-specific best practices for each language (Python, JavaScript, Java, etc.).
   - Regularly review language documentation and style guides.

3. Consistency Across Codebases
   - Maintain uniform coding conventions and naming schemes across all languages used within a project.

Project Context & Understanding

1. Documentation First
   - Review essential documentation before implementation:
     - Product Requirements Documents (PRDs)
     - README.md
     - docs/architecture.md
     - docs/technical.md
     - tasks/tasks.md
   - Request clarification immediately if documentation is incomplete or ambiguous.

2. Architecture Adherence
   - Follow established module boundaries and architectural designs.
   - Validate architectural decisions using symbolic reasoning; propose justified alternatives when necessary.

3. Pattern & Tech Stack Awareness
   - Utilize documented technologies and established patterns; introduce new elements only after clear justification.

Task Execution & Workflow

Task Definition & Steps

1. Specification
   - Define clear objectives, detailed requirements, user scenarios, and UI/UX standards.
   - Use advanced symbolic reasoning to analyze complex scenarios.

2. Pseudocode
   - Clearly map out logical implementation pathways before coding.

3. Architecture
   - Design modular, maintainable system components using appropriate technology stacks.
   - Ensure integration points are clearly defined for autonomous decision-making.

4. Refinement
   - Iteratively optimize code using autonomous feedback loops and stakeholder inputs.

5. Completion
   - Conduct rigorous testing, finalize comprehensive documentation, and deploy structured monitoring strategies.

AI Collaboration & Prompting

1. Clear Instructions
   - Provide explicit directives with defined outcomes, constraints, and contextual information.

2. Context Referencing
   - Regularly reference previous stages and decisions stored in the memory bank.

3. Suggest vs. Apply
   - Clearly indicate whether AI should propose ("Suggestion:") or directly implement changes ("Applying fix:").

4. Critical Evaluation
   - Thoroughly review all agentic outputs for accuracy and logical coherence.

5. Focused Interaction
   - Assign specific, clearly defined tasks to AI agents to maintain clarity.

6. Leverage Agent Strengths
   - Utilize AI for refactoring, symbolic reasoning, adaptive optimization, and test generation; human oversight remains on core logic and strategic architecture.

7. Incremental Progress
   - Break complex tasks into incremental, reviewable sub-steps.

8. Standard Check-in
   - Example: "Confirming understanding: Reviewed [context], goal is [goal], proceeding with [step]."

Advanced Coding Capabilities

- Emergent Intelligence
  - AI autonomously maintains internal state models, supporting continuous refinement.
- Pattern Recognition
  - Autonomous agents perform advanced pattern analysis for effective optimization.
- Adaptive Optimization
  - Continuously evolving feedback loops refine the development process.

Symbolic Reasoning Integration

- Symbolic Logic Integration
  - Combine symbolic logic with complexity analysis for robust decision-making.
- Information Integration
  - Utilize symbolic mathematics and established software patterns for coherent implementations.
- Coherent Documentation
  - Maintain clear, semantically accurate documentation through symbolic reasoning.

Code Quality & Style

1. TypeScript Guidelines
   - Use strict types, and clearly document logic with JSDoc.

2. Maintainability
   - Write modular, scalable code optimized for clarity and maintenance.

3. Concise Components
   - Keep files concise (under 300 lines) and proactively refactor.

4. Avoid Duplication (DRY)
   - Use symbolic reasoning to systematically identify redundancy.

5. Linting/Formatting
   - Consistently adhere to ESLint/Prettier configurations.

6. File Naming
   - Use descriptive, permanent, and standardized naming conventions.

7. No One-Time Scripts
   - Avoid committing temporary utility scripts to production repositories.

Refactoring

1. Purposeful Changes
   - Refactor with clear objectives: improve readability, reduce redundancy, and meet architecture guidelines.

2. Holistic Approach
   - Consolidate similar components through symbolic analysis.

3. Direct Modification
   - Directly modify existing code rather than duplicating or creating temporary versions.

4. Integration Verification
   - Verify and validate all integrations after changes.

Testing & Validation

1. Test-Driven Development
   - Define and write tests before implementing features or fixes.

2. Comprehensive Coverage
   - Provide thorough test coverage for critical paths and edge cases.

3. Mandatory Passing
   - Immediately address any failing tests to maintain high-quality standards.

4. Manual Verification
   - Complement automated tests with structured manual checks.

Debugging & Troubleshooting

1. Root Cause Resolution
   - Employ symbolic reasoning to identify underlying causes of issues.

2. Targeted Logging
   - Integrate precise logging for efficient debugging.

3. Research Tools
   - Use advanced agentic tools (Perplexity, AIDER.chat, Firecrawl) to resolve complex issues efficiently.

Security

1. Server-Side Authority
   - Maintain sensitive logic and data processing strictly server-side.

2. Input Sanitization
   - Enforce rigorous server-side input validation.

3. Credential Management
   - Securely manage credentials via environment variables; avoid any hardcoding.

Version Control & Environment

1. Git Hygiene
   - Commit frequently with clear and descriptive messages.

2. Branching Strategy
   - Adhere strictly to defined branching guidelines.

3. Environment Management
   - Ensure code consistency and compatibility across all environments.

4. Server Management
   - Systematically restart servers following updates or configuration changes.

Documentation Maintenance

1. Reflective Documentation
   - Keep comprehensive, accurate, and logically structured documentation updated through symbolic reasoning.

2. Continuous Updates
   - Regularly revisit and refine guidelines to reflect evolving practices and accumulated project knowledge.

# from https://www.linkedin.com/pulse/how-hyper-optimize-cursorclineroo-automation-reduce-costs-cohen-suxhc/

# SPARC Focus: Specification - Define project objectives, requirements, and user scenarios
test_coverage:
  required: true                         # Ensure all code changes are backed by tests
  minimum_percentage: 80                 # Set a baseline of 80% test coverage
  exclude_paths:                         # Exclude paths that do not require testing
    - test/fixtures
    - scripts

# SPARC Focus: Specification - Set guidelines for code quality
lint_rules:
  disable_requires_approval: true        # Require explicit approval to disable lint rules
  enforce_eslint: true                   # Enforce ESLint for code consistency
  enforce_prettier: true                 # Enforce Prettier for consistent formatting

# SPARC Focus: Specification - Define styling and UI/UX guidelines
styling:
  use_tailwind: true                     # Utilize Tailwind CSS for standardized design
  prefer_functional_components: true     # Prefer functional components for UI development
  css_variables_location: webview-ui/src/index.css  # Central location for CSS variable definitions

# SPARC Focus: Specification - Environment-specific configurations
environments:
  python:
    virtual_env: true                    # Use a virtual environment for Python projects
    linter: flake8                       # Lint Python code with Flake8
    formatter: black                     # Format Python code with Black
  node:
    package_manager: npm                 # Use npm as the package manager
    test_runner: jest                    # Use Jest for running JavaScript tests

# SPARC Focus: Pseudocode & Architecture - Model configuration for AI integration
provider:
  default: google/gemini-2.5-pro-experimental   # Default AI model provider
thinkingProvider:
  model: google/gemini-2.0-flash                # Model for quick, responsive analysis
docModel: google/gemini-2.0-pro                 # Model for processing documentation

# SPARC Focus: Pseudocode - Operational mode for code processing
mode: code                                      # Set the mode to 'code' for development tasks

# SPARC Focus: Architecture - Real-time updates configuration
real_time_updates:
  enabled: true                                 # Enable real-time context updates
  update_triggers:
    project_related:
      - documentation_gap                       # Trigger when documentation is incomplete
      - knowledge_update                        # Trigger upon new information or updates
    system_related:
      - error_pattern                           # Trigger when repeated error patterns are found
      - performance_insight                     # Trigger when performance insights become available

# SPARC Focus: Refinement - Use unified diffs for structured code edits
edit_format: unified_diff                       # Adopt unified diff for clear code modifications
high_level_edits: true                          # Encourage holistic, high-level changes
exclude_line_numbers: true                      # Exclude line numbers for cleaner diffs

# SPARC Focus: Architecture - Mode switching for multiple development contexts
mode_switching:
  enabled: true                                 # Allow automatic mode switching
  preserve_context: true                        # Retain context during mode transitions

# SPARC Focus: Pseudocode - Intent-based triggers for switching modes
intent_triggers:
  code:
    - implement                                 # Switch to code mode for implementing features
    - create                                    # Switch to code mode for creating components
    - build                                     # Switch to code mode for building modules
    - fix                                       # Switch to code mode for fixing issues
  architect:
    - design                                    # Switch to architect mode for designing systems
    - structure                                 # Switch to architect mode for structural planning
    - plan                                      # Switch to architect mode for project planning

# SPARC Focus: Architecture - File-based triggers for dynamic mode switching
file_triggers:
  - pattern: "\.tsx$"                           # Activate code mode for TSX files
    target_mode: code
    condition: file_edit
  - pattern: "\.md$"                            # Activate document mode for Markdown files
    target_mode: document
    condition: file_create

# SPARC Focus: Refinement - Terminal command management
terminal:
  allowed_commands:
    - npm test                                  # Run JavaScript tests
    - npm install                               # Install Node dependencies
    - tsc                                       # Compile TypeScript code
    - git log                                   # Show commit history
    - git show                                  # Display Git object content
    - cd                                        # Change directory
    - pip                                       # Install Python packages
    - docker                                    # Execute Docker commands
    - cd ../                                    # Move one directory up
    - python                                    # Run Python interpreter
    - aider                                     # Custom or third-party script
    - streamlit                                 # Launch Streamlit for Python web apps
    - export                                    # Set environment variables
    - ls                                        # List directory contents
    - coverage                                  # Check code coverage
    - node                                      # Run Node.js commands
    - npm run                                   # Execute npm scripts
    - cargo                                     # Use Cargo for Rust projects
    - pytest                                    # Run Python tests with pytest
    - source                                    # Source environment variables
    - cd agents/                                # Navigate to agents directory
    - cd parser                                 # Navigate to parser directory
    - chmod                                     # Change file permissions
    - mkdir                                     # Create a new directory
    - bash                                      # Run Bash commands
    - curl                                      # Transfer data from or to a server
    - npx                                       # Execute npm package binaries
    - sparc2run                                 # Custom or third-party script
    - uvicorn                                   # ASGI server for Python
    - pkill                                     # Kill processes by name
    - pwd                                       # Print working directory
    - grep                                      # Search for text patterns
  blocked_commands:
    - rm -rf                                    # Prevent dangerous recursive deletion
    - git push                                  # Block pushing changes without review

# SPARC Focus: Architecture - Model Control Panel (MCP) integration
mcp_server:
  enabled: true                                 # Enable MCP server features
  url: http://localhost:3000                    # MCP server URL
  auth_token: local_dev_token                   # Authentication token for local environment
  features:
    - code_search                               # Enable code searching functionality
    - project_indexing                          # Index projects for faster lookups

# SPARC Focus: Refinement - Automatic checkpoints for safe code recovery
checkpoints:
  enabled: true                                 # Turn on automatic checkpointing
  auto_save: true                               # Save checkpoints automatically
  interval_minutes: 15                          # Checkpoint interval in minutes
  max_checkpoints: 5                            # Maximum number of stored checkpoints

# SPARC Focus: Refinement - Configure repository search
repository_search:
  enabled: true                                 # Activate repository search
  exclude_paths:
    - node_modules                              # Exclude node_modules folder for efficiency
    - .git                                      # Exclude Git repository metadata
    - dist                                      # Exclude distribution output
  include_file_types:
    - .ts                                       # Include TypeScript files
    - .tsx                                      # Include TSX files
    - .js                                       # Include JavaScript files
    - .jsx                                      # Include JSX files

# SPARC Focus: Completion - Custom command shortcuts
command_shortcuts:
  start_dev: npm run dev                        # Shortcut to start the development server
  run_tests: npm test                           # Shortcut to run test suites
  build_project: npm run build                  # Shortcut to build the project
  deploy_staging: npm run deploy:staging        # Shortcut to deploy to a staging environment

# SPARC Focus: Completion - Manage memory for dynamic context updates
memory_bank:
  update_requests:
    high_priority:
      - activeContext.md                        # Update active context details
      - progress.md                             # Log ongoing progress
    medium_priority:
      - decisionLog.md                          # Track significant decisions
      - productContext.md                       # Capture product-specific context


